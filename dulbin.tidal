d1 $ s "[bd*4]" # n 8
d1 $ s "[bd*4,[~ cp]*2]" # n 8
d1 silence

d3 $ fast 2 $ s "~ [[ul]*2 ~]" # n 0 # gain 1.2
d3 silence

-- ?
d4 $ fast 2 $ scramble "1 2 3 4" $ s "yeah*4" # n "1 2 3 4"
-- iya
d4 $ fast 2 $ s "voodoo*8" # n "[1 2 3 4]*3" # freq "200 300"
-- heheh
d4 $ fast 2 $ s "sid*8" # n "[1 2 3 4]*3" # freq "100 300 400"
d4 silence

d5 $ juxBy 0.3 rev $ sometimes (fast 2) $ s "psr*8" # n "1 2 3 4 6"
d5 $ juxBy 0.3 rev $ sometimes (fast 2) $ s "industrial*8" # n "2 3 9" # gain 0.9 # freq "100 700"
-- iya
d5 $ juxBy 0.3 rev $ repeatCycles 4 $ sometimes (fast 2) $ s "psr*8" # n (shuffle 5 "1 2 3 4 6")
d5 silence


hush

d4 silence

d1 $ fast 2 $ repeatCycles 4 $ n (shuffle 8 (run 8)) # s "arpy"


shuffle 8 (run 8)

(1 ~>) $ shuffle 8 (run 8)


d1 $ s "bd*4 cp"

-------------------------------
setcps (140/240)

d2 $ s "bd*4"
d2 silence

d1 $ "bd(5,16,1)"
d1 silence

d2 $ s "hh!16"

d3 $ "[~ sn]!2"
d3 silence

d4 $ s "bass1(3,8)" # legato 0.2

hush

---------------------------------
d1 $ repeatCycles 128 $ (0 ~>) $ s "gab!16" # n (irand 13) # up "10,-13,15,-17" # gain 0.7 -- vary (0 ~>)
d1 silence

d2 $ repeatCycles 128 $ s "bottle!16" # n (irand 13) # up "-24,-13,15,-17" # gain "1"
d2 silence

d3 $ repeatCycles 128 $ s $ scramble 16 "[bd sn cp hh]!2"
d3 silence

------------------------------- bf

d1 $ s "hitz03" +| n (run 8) # cut 1

d1 silence

d2 $ repeatCycles 8 $ (6 ~>) $ s "arum!16" # n (irand 8) + 24 # cut 1 # gain 1
d2 $ every 2 (degrade) $ repeatCycles 8 $ (6 ~>) $ s "arum!16" # n (irand 8) + 24 # cut 1 # gain 1
d2 silence

hush
d3 $ n "[d3!4 f3!2 c3!2]/2" # s "superreese" # gain 0.9 # sustain 0.4
d3 silence

-------------------------------- bf

d1 $ sometimes (fast 2) $ s "threequal!4" # n "4 5 6 7" # speed "<1 0.25 8>" # room 1 # size 0.5 # orbit 1
d1 silence

d2 $ repeatCycles 4 $ jux rev $ s "threequal!16" # n (irand 16) # speed "1 2 0.75 -0.5" # crush "3 6 9 11" # gain 1
d2 silence

d3 $ degrade $ s "ppsus" +| up (run 8) + 4 # n (run 19) * 2 # waveloss "10 90"
d3 silence

--------------------------------- string trio 18/2/2020

d1 $ s "<tptm!7 tptm!5 tptm!9>*4" # n (irand 3)
d1 silence
hush

d1 $ s "ppsus" +| n " 9 15 21" # freeze 1
hush

d1 $ fast "1 2? 3 4? 5" $ s "tptm!4" # n (irand 32)
d1 $ shuffle 5 $ fast "1 2? 3 4? 5" $ s "tptm!4" # n (irand 32) # freeze 1
d1 $ sometimes (fast "3 4 5") $ s "tptm!4" # n (irand 32) -- # freeze 1
d1 $ sometimes (slow "3 4 0.5") $ s "ppsus!4" # n (irand 2 + 9) --  # octer 1
d1 $ sometimes (fast "3 4") $ s "ppsus!4" # n (irand 2 + 2) --  # octer 1
d1 $ sometimes (slow "3 4") $ s "ppsus!4" # n (irand 7 + 15) # freeze 1 # gain 0.2
d1 silence

play scales in A major, faster
leave out the g#
don't play g#
nico play g natural or any note in key of d
in tempo
strong pulse
driving
faster

violins stop playing c sharps
all using d major
when I say now, suddently to Ab major
now
back to d……… now
suddently out of time, slow long notes
chromatica
microtonal

stop

play, please
I like that
I like the slidey stuff
sounds like we've sort of slid somewhere else
don't build too far
get back to the first lot of sounds
beautiful

we need a sudden gesture
or maybe not

nico, contradict me
disagree strongly

go back to that first texture
I think the piece is ending soon

------------------------ structure experiments

-- d1 $ fast "1 3 5" $ s "superpiano" -- hmm, hard to understand!
d1 $ s "superpiano"
d1 $ n 0 # s "superpiano"
d1 $ n "0 3" # s "superpiano"
d1 $ s "superpiano!2"
d1 $ n "0 3" # s "superpiano!3" -- structure is two notes
d1 $ s "superpiano" # n "0 3" -- structure is one note
d1 $ s "superpiano!3" + n "0 3" -- structure from both patterns
d1 $ s "superpiano!2" # n "0 3 5" -- structure from the left
d1 $ s "superpiano!2" |> n "0 3 5" -- same, structure L values R
d1 $ n "0 3 5" |> s "superpiano" -- same, structure L values R
d1 $ n "0 3 5" <| s "superpiano!5" -- structure R, values L
d1 $ n "0 3 5" +| s "superpiano!5" -- here means the same, not addition
d1 $ n "0 3 5" |< s "superpiano" -- same as |> ? pipe points to structure
d1 $ n "0 3 5" >| s "superpiano!5" -- same as <| ?
d1 $ n "0 3 5" # n "1 2 0 19" # s "superpiano" -- usual struct L values R
d1 $ n "0 3 5" |> n "1 2 0 19" # s "superpiano" -- same
d1 $ n "0 3 5" <| n "19 99 20 19" # s "superpiano" -- struct R ignores values!
d1 $ n "0 3 5" + n "1 2 5 8" # s "superpiano" -- actual addition, combined struct
d1 $ n "0 3 5" |+ n "12 0 0 88" # s "superpiano" -- struct L, addition, 88 ignored
d1 $ n "0 3 5" +| n "0 0 3 9" # s "superpiano" -- struct R, addition
d1 $ n "0 3 5" * n "0 0 3 9" # s "superpiano" -- struct R, mult combined struct
d1 $ n "0 3 5" / n "0 0 3 9" # s "superpiano" -- struct R, division combined struct

d1 silence

---------------------- from tidal-snippets
-- Kind of granular -- slow down while pitch up:

d1 $ fast 20 $ struct (binary 205) $ s "numbers"
# attack 0.02 # hold 0.0 # release 0.02
# begin (slow (2*20) $ range 0.0 0.4 $ saw)
# speed 1.2
# pan rand

d1 silence

--------------------
-- https://chat.toplap.org/channel/tidal?msg=yd7zqq6hFqApxBYRc
d1 $ every 2 rev $ s "{bd@7 bd@7 cp@11 cp bd@13 hh hh hh cp@10}%16"
d1 $ s "{bd cp@4 bd@3 sn@3, arpy}%16"
d1 $ s "[bd cp@4 bd@3 sn@3]*2"
d1 silence

---------------------- domram

d1 $ s "drumtraks" <| n "[6!4, [~ 4]*4, [~ 9]*2] "
d1 $ shuffle 4 $ n (run 8) # s "drumtraks"
d1 $ n (run 8) # s "drumtraks"
d1 $ shuffle 16 $ s "bd sn cp hh" <| n (run 16)
d1 $ repeatCycles 1024 $ (2 ~>) $ shuffle 16 $ s "808bd 808sd 808hh 808" <| n (run 16)
d1 $ repeatCycles 16 $ s "jungle!16" # n (irand 13)
d1 $ repeatCycles 4 $ slow 2 $ s "amencutup!32" # n (irand 32)
d1 $ repeatCycles 4 $ s "peri!16" # n (irand 15) # speed 2 -- iya

d1 silence

----------------------- iya
d1 $ s "drumtraks" <| n "[6!4, [~ 4]*4, [~ 9]*2] "
d2 $ n "0 .. 7" # sound "superzow(5,8)" # octave 3 # gain 0.9
d3 $ n "0" # "superhoover" # octave "[3,4]" # sustain 2 # gain 0.9
d4 $ repeatCycles 4 $ s "peri!16" # n (irand 15) # speed 2 -- y

hush

----------------------

How can I get a polymetric effect across two different patterns? This doesn't work, but something like
`d1 $ s "arpy!4" # n "0 1 2"` where the intention is to have a quarter note pulse with a rotating three note arpeggio that would repeat every three bars `"0 1 2 0  1 2 0 1  2 0 1 2"`

d1 $ fast 3 $ s "arpy!12" <|  n "0 1 2"

d1 $ s "arpy!12" <|  n "[0 1 2]!3" -- tempo is wrong
d1 $ fast (1/3) $ s "arpy" <|  n "[0 1 2]*3"


resetCycles

d1 $ fast (1/3) $ s "arpy" <| n "0 1 2 0 1 2 0 1 2 0 1 2" -- correct, but?!?!? must be a better way

d2 $ s "bd!4"

d1 $ "arpy" # n 2
d1 silence

hush

-- kindohm yay
d1 $ s "arpy*4" # n "{0 1 2}%4"


--------------- chords

jumpIn' 1 1 $ slow 2 $ n "c'maj(5,8) e'min(3,8) d'min(3,8,1) f'maj(5,8)" # s "supermandolin" # sustain 1 # gain 1.1 -- iya
d2 $ s "bd:4!4" # gain 0.8
d2 $ s "[bd:4!4, [~ sn:6]!2]" # gain 0.8
hush
d3 $ n "c3(5,16)" + n "0 12 12 7" # sound "superzow" # gain 0.65 # sustain 0.3

d1 $ every 2 (fast 2) $ s "superpiano" <| n (arp "<converge updown>" "<c'nine ef'dom7'8 a'7sus2*2>")
d2 $ s "superpiano" <| n (arp "<diverge up>" "<c4'nine ef4'dom7'8 a4'7sus2*2>")
d3 $ s "superpiano" <| n (arp "<diverge disconverge>" "<d3'ninesus4 f3'dom7'8 as3'7sus4>")
d4 $ every 2 (slow 2) $ s "superpiano" <| n (arp "<diverge disconverge>" "<e2'm7sharp9 g2'sixby9 af2'3m7sharp5flat9>") -- iya

hush

-------------------

d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (range 0 28 perlin) -- microtonal
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (range 0 28 $ perlinWith saw) -- nope
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (slow 4 $ range 0 28 perlin) -- iya
d1 $ repeatCycles 4 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (slow 4 $ range 0 28 perlin) -- can't see how to vary number of repeat cycles
d1 silence

-- yaxu
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (quantise 1 $ range 0 28 perlin)

----------------- sldi

d1 $ repeatCycles 4 $ fast 4 $ loopAt 2 $ shuffle 8 $ chop 8 $ s "sldiwaloops:0" # cut 1 # speed "2 1 0.5" # n "<0 1 2 3>" -- iya
d1 silence

d2 $ s "808bd:2!4" # gain 1.1 -- also load default samples
solo 2
unsolo 2

hush

------------------- iya
setcps (140/60/4)

d1 $ scramble 8 $ s "sixo" <| n (run 8)
d1 $ every 4 (const $ s "sixo!16" # n "{0 4 5}%16") $ scramble 8 $ s "sixo" <| n (run 8)

d2 $ slow 2 $ scramble 16 $ chop 16 $ "sldiwaloops" # cut 1 # n 17 # gain 1 # speed "{0.5 1 0.25}%16"

-- d1 $ s "sixo!8" # n (scramble 8 $ run 8) -- same as above?

hush

------------------- useful

d1 $ s "[mt mt] bd" -- quaver quaver crotchet
d1 $ s "mt*2 bd" -- same
d1 $ s "mt mt . bd" -- same
d1 $ s "mt mt bd" -- triplets
d1 $ s "mt!2 bd" -- triplets

-------------------- pitched sounds in estuary?
-- superpiano default note is A 440
-- pitched samples
-- arpy:0 = C

hush

d1 $ s "superpiano"
d1 $ s "superpiano" # n "cs"
d1 $ s "superpiano" <| n "c cs d ef e f fs g af a bf b c6"
-- d1 $ s "arpy" <| n "c cs d ef e f fs g af a bf b c6" not n!
d1 $ s "arpy" <| up "c cs d ef e f fs g af a bf b c6" -- use up

-------------------- chop like slice
d1 $ slow 2 $ repeatCycles 4 $ shuffle 16 $ chop 16 $ s "sldiwaloops" # n "<0 1>*8"

-------------- different style, 06:23 Sat 21 Mar Ivan Abreu

-- putting it all in one stack more compact, but less flexible?
-- dont' understand why first line out different bit
d1 $ stack [
  n "{0? 1? 2@e 4}%8" # s "{print sid industrial}%4" # gain 0.9,
  n "0!16" # s "metal" # gain (range 0.8 1 $ slow 1.1 saw),
  s "dr2!4" # n "{3 5}%4"
]

-- 2020-03-22
-- on a single sound, can't detect a difference

d1 $ s "{e}%4" |> n "0 1 2 3 5" -- structure of four
d1 $ s "e!4" |> n "0 1 2 3 5" -- also?
d1 $ s "e*4" |> n "0 1 2 3 5" -- also?!
-- test other way
d1 $ s "{e}%4" <| n "0 1 2 3 5" -- same
d1 $ s "e!4" <| n "0 1 2 3 5" -- same
d1 $ s "e*4" <| n "0 1 2 3 5" -- same


d1 $ s "arpy e"
d1 $ s "{arpy e}%4" |> n "2 4 6 8 10" -- four
d1 $ s "[arpy e]!2" |> n "2 4 6 8 10" -- four, but
d1 $ s "[arpy e]*2" |> n "2 4 6 8 10" -- four, but

----------------
asap $ s "sldiwaloops" # n 0

-- no, loopAt repitches
d1 $ loopAt 2 $ s "sldiwaloops" # n 0

-- ok, but very short release, nasty click
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16)
-- this is not right, its like a decay, not a release
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16) # release 0.5
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16) # release 0.5

d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16)

I'm still struggling with how to neatly use sections from a longer cycle. If I do this, the envelope at the end of the sample is very short indeed, and you get a distinct click at the end:

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16)

If I do this, then it does not do what I would expect, which would be to play up to the 'end' and then add a release tail. Instead of being a 'release', it's more like the 'decay' of an up-and-down a/d envelope.

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16) # release 0.5

In the slicing sampler I use in SC, I have a fast attack but a release tail at the end of the sample of 0.1, which I find works well. How can I do that in Tidal? Do I need to hack SuperDirt?

-----------------

-- ok, this is better than begin and end, but same problem with release
-- (effectively, this is a bit like dice, but not as good)
d1 $ slice 16 "0" $ s "sldiwaloops" # n 0

-- also sustain, still not right
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # sustain (1/16) # release 1

d1 $ s "sldiwaloops" # n 0 # begin (0/16)

-- do synths release correctly?
-- computer says no

d1 $ s "tutorial2a!4"

d2 $ s "909"

-- add extra sustain to allow for a tail?
-- disnae wurk

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16) + 3 # release 0.2

----------------------
-- ideas from building up patterns, meh

d1 $ chunk 4 (|- n 12) $ rarely (ply 2) $ arp "up down pinkyup updown" $ n "c4'maj7 ef4'maj7" # s "supermandolin" # legato 5 # room 0.7 # size 0.9

---------------------
setcps (160/240) -- actually, this is quite nice at default tempo!

d1 $ s "ul!8" # n (shuffle 4 $ run 8) -- iya
jumpIn' 1 0 $ every 4 (rev) $ s "ul!8" # n (repeatCycles 4 $ shuffle 4 $ run 8)

jumpIn' 2 0 $ superimpose (|+ n 12) $ n "c2" # gain 0.7 # s "superzow"

jumpIn' 2 0 $ superimpose (|+ n 12) $ cat [n "c2", n "c3 bf2 g2 bf2 ~ g2 f2 ~"] # gain 0.7 # s "superzow"
-- oops forgot about octave, much simpler!
jumpIn' 2 0 $ cat [n "c2", n "c3 bf2 g2 bf2 ~ g2 f2 ~"] # gain 0.7 # s "superzow" # octave "[5,6]"



------------------- iya during that trashpanda thing

d1 $ slowstripe 4 $ slice 128 (shuffle 5 $ run 128) $ s "hmm" # gain 1.5 # speed (slow 2 $ range 4 0.25 $ perlin)

d2 $ slowstripe 5 $ often (slow 8) $ s "insect!3 crow" # gain "1.4 1" # speed (slow 2 $ range 0.25 0.125 $ sine) # n (run 3)

d3 $ sometimesBy 0.25 ((hurry 4) . rev) $ s "supervibe" # n "c4'maj7" +| n "0 <3 5> 7 5 -2" # sustain 1 # room 0.5 # sz 0.8

d4 $ s "amencutup!16" # n (scramble 32 $ run 32)

-------------------- investigate long sample again

let bpm x = setcps (x/120/2)

bpm 130

once "ade"
-- pitches it to one current cycle
d1 $ loopAt 1 $ s "ade"
-- or four
d1 $ loopAt 4 $ s "ade"
-- plays one of 64 slices, length played is 1/64
d1 $ slice 64 1 $ s "ade"
-- seems clumsy, also that nasty fast release
-- js style 'slice' is just not really possible!
d1 $ s "ade" # begin (1/64) # legato 1
-- also doesn't work
d1 $ s "ade" # begin ("1 2" / 64) # legato 1

-- go with the idiom

d1 $ slice 64 (run 8) $ s "ade" -- pitch is same as orig sample
-- don't understand, pitch is now lower?
d1 $ splice 64 (run 8) $ s "ade"
-- ah, is kind of granular, so pitch depends on how many samples you run through
-- horrible envelope for granular!
d1 $ splice 64 (run "<8 16 32 64>") $ s "ade"
-- back to slice? pitches always same
d1 $ slice 64 (run "<8 16 32 64>") $ s "ade"
-- just messing
d1 $ slice 64 (run "<8 16 32 64>") $ s "ade" # speed (slow 8 $ range 2 0.25 sine)

--------------- longer term change (sldiwaloops)

bpm 120

-- think this is right as a pattern, but does not sound great
d1 $ slice 16 (repeatCycles 4 $ shuffle 16 $ run 16)
  $ s "sldiwaloops" # n "<0 1 2 3>/4" +| n "<0 8>/16" # legato 0.9


d1 $ cat [sound "bd*2 sn", sound "arpy crow*2"]

d1 $ fast 32 $ s "<bd cp>/16" |+ s "<sd 808 909 ul>/4"

d1 $ interlace (sound  "bd sn kurt") (every 3 rev $ sound "crow ul")

-- iya! <> is overlay as an operator
d1 $ sound ("bd sn:2" <> "jungle:5*3" <> "hh!12" <> "808:8(5,12,1)" <> "psr:6!6")

-- this is quite long and nicely varied
-- pulse needs to vary on longer term, perhaps

d1 $ rarely (hurry 0.25) $ slow 2 $ n (repeatCycles 4 $ shuffle 32 $ run 32) # s "<flext erra tptm pp>/8"



---------------
-- bit extreme!
d1 $ repeatCycles 4 $ s "supergrind" <| shuffle "<5 6>" (n "0 .. 7" * 2 - 24) # detune (slow 4 $ range 0 200 sine) # voice 4 # sustain 1

d1 $ slow 4 $ s "supervibe" <| n "c'major7 bf4'major7 [cs4,d5,fs5,a5]" # attack 0.1 # release 4


----------------- trying to figure out envelopes again
-- legato?
-- sustain?
-- attack?
-- release?

bpm 120

d2 $ s "click!4"
-- Can anyone explain the difference between 'legato' and 'sustain'? In each of the examples I'm trying below the effect is the same, except for the last one?!?

-- legato
d1 $ s "superzow" # n "c" # legato 1
d1 $ s "superzow" # n "c" # legato 2
d1 $ s "superzow!2" # n "c" # legato 0.5
d1 $ s "superzow" # n "c" # legato 0.5 -- different?
-- sustain
d1 $ s "superzow" # n "c" # sustain 1
d1 $ s "superzow" # n "c" # sustain 2
d1 $ s "superzow!2" # n "c" # sustain 0.5
d1 $ s "superzow" # n "c" # sustain 0.5 -- different?```
```-- attack seems to set sustain to zero?
d1 $ s "superzow" # n "c" # attack 0.1
-- release also sets sustain to zero?
d1 $ s "superzow" # n "c" # release 0.5
-- attack plus release, again sustain is zero
d1 $ s "superzow" # n "c" # attack 0.1 # release 0.5
-- sustain and/or legato makes no difference?
d1 $ s "superzow" # n "c" # attack 0.1 # release 0.5 # sustain 1
d1 s "superzow" # n "c" # attack 0.1 # release 0.5 # legato 1
```
so, it seems to be impossible to control the length and attack/decay of a synth independently in tidal?

--------------------- larger structures
bpm 120

do
{
  resetCycles;
  d1 $ rotL 0 $ seqP [
    (0, 12, sound "bd bd*2"),
    (4, 12, sound "hh*2 [sn cp] cp future*4"),
    (8, 12, sound (samples "arpy*8" (run 16)))
  ]
}


jumpIn' 1 1 $ s "909"
jumpIn' 1 8 $ silence

p "drums" $ s "bd(3,8) drum*4"

xfadeIn "drums" 4 $ s "arpy*8" # n (run 8)
clutchIn "drums" 4 $ s "arpy*8" # n (run 8)
jumpIn' "drums" 4 $ s "arpy*8" # n (run 8)
anticipateIn "drums" 4 $ s "arpy*8" # n (run 8)

-- transition between two named patterns??
-- ur? with repeatCycles? yes, that's it, looks deep!

let pats = [("drums", s "drum cp*2"),
            ("melody", s "arpy:2 arpy:3 arpy:5"),
            ("craziness", s "cp:4*8" # speed ( sine + 0.5))
           ]
    fx = [("higher", (# speed 2))]
in
d1 $ ur 8 "[drums, melody] [drums,craziness,melody] melody:higher" pats fx


------------------ agint
-- 0 == c

d1 $ n "[-13,-2,1,3,6]" # s "superpiano"

-- disnae wurk, asked question
let chorda = "[-13,-2,1,3,6]"
    chordb = "[-22,-3,0,4,6]"
in
d1 $ n "chorda chordb" # s "superpiano"

do
{ resetCycles;
  jumpIn' 1 0 $ slow 4 $ n "[-13,-2,1,3,6] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5]@2 [-15,-1,0,4,7] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5] [-18,-2,1,4,8] [-13,-2,1,3,6]@2 [-19,-2,0,3,7] [-14,-4,0,2,5]" # s "superpiano"
}

d1 $ reset (-4) $ slow 4 $ n "[-13,-2,1,3,6] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5]@2 [-15,-1,0,4,7] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5] [-18,-2,1,4,8] [-13,-2,1,3,6]@2 [-19,-2,0,3,7] [-14,-4,0,2,5]" # s "superpiano"

-- still not right!
d1 $ reset 1 $ n "{[-13,-2,1,3,6] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5]@2 [-15,-1,0,4,7] [-22,-3,0,4,6] [-17,-3,-1,2,6] [-14,-4,0,2,5] [-21,-5,-2,2,5] [-18,-2,1,4,8] [-13,-2,1,3,6]@2 [-19,-2,0,3,7] [-14,-4,0,2,5]}%2" # s "superpiano"


-- minimal example

How can I make it so that I can hear this pattern start from the beginning at n = 0 as soon as I execute it?

```d1 $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 8 10 11@2 12 13" #  s "superpiano"

-- this doesn't work
jumpIn' 1 0 $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 8 10 11@2 12 13" #  s "superpiano"

-- this doesn't work
do
{ resetCycles;
  d1 $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 9 10 11@2 12 13" #  s "superpiano"
}

-- this *seems* to work, but have to wait 14 beats for it to start
jumpMod 1 14 $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 9 10 11@2 12 13" #  s "superpiano"
```

-- yaxu, doesn't work, starts on fourth beat
d1 $ reset 1 $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 9 10 11@2 12 13" #  s "superpiano"

-- because of slow 4 (?) need to do this:
d1 $ reset (-4) $ slow 4 $ n "0 1 2 3 4@2 5 6 7 8 9 10 11@2 12 13" #  s "superpiano"

`d1 $ reset
hush


---------------- midi

d1 $ slow 2 $ n "c'major7 bf4'major7" # s "midi" # legato 0.2

d2 $ n "c3(5,8)" # s "superreese" # gain 0.65 # room 0.5 # sustain 0.4


------------------ tidal version 1.4.9

drawLine "[a b <c [d e]>, x(3,8,<0 2 4>)]"
draw "[a b <c [d e]>, x(3,8,<0 2 4>)]"

drawLine "kick [kick/2 kick]"

```draw "kick [kick/2 kick]"
|k-------i-------c-------k-------kick-ick
```

----------- calum
-- https://www.twitch.tv/further_in
let (>) = (#)

-- ssh mute function
-- kindohm has gtfo
-- let gtfo p = (const $ midinote "~") $ p
-- let shh = (# gain 0) from  diegodorado / tidal-songs
-- buffer flood how to?

----------------melodies?
bpm 120
scaleList

d1 $ n (scale "pelog" "[0 .. 7]") # s "superpiano"

d1 $ n (shuffle 8 $ scale "pelog" "0 .. 7") # s "superpiano"

d1 $ struct "t t f t" $ shuffle 8 $ n (scale "pelog" "0 .. 7") # s "superpiano" # legato 1.5

d1 $ shuffle 8 $ n (scale "pelog" "0 .. 7") # s "superpiano" # legato 2

d1 $ s "superpiano!8" # n (range 0 14 perlin) |* "[2 | 3]"

d1 $ s "superpiano!8" # n (range 0 14 perlin)

d1 $ scramble 8 $ n (scale "pelog" "0 .. 7") |+ irand 2 # s "superpiano" # legato 2

d1 $ n (scale "pelog" "0 .. 7") |+ irand 2 # s "superpiano" # legato 2

d1 $ n (scale "pelog" "0 .. 7") # s "superpiano" # legato 2

d1 $ s "superpiano!8" # n (range 0 14 perlin) |+ irand 3 -- better

--
d1 $ n (scale "pelog" "[0 .. 7]") |+ n (fast 8 $ range (-5) 5 perlin) # s "superpiano"

-- aha, at last that sounds like a brownian melody with not too many repeats!
-- but not staying in pelog scale!
d1 $ n (scale "pelog" "0!8") |+ n (fast 8 $ range (-5) 5 perlin) # s "superpiano"
-- still not staying in scale
d1 $ n (scale "pelog" "0!8" |+ (fast 8 $ range (-5) 5 perlin)) # s "superpiano"

```-- here's a random walk on a chromatic scale:
d1 $ struct "1!8" $ n (fast 8 $ range (-5) 5 perlin) # s "superpiano"
-- how could I make a random walk constrained to a particular named scale?
-- this is not it quite it, adds random *chromatic* intervals
d1 $ n (scale "pelog" "0!8" |+ (fast 8 $ range (-5) 5 perlin)) # s "superpiano"
```




hush
