d1 $ s "[bd*4]" # n 8
d1 $ s "[bd*4,[~ cp]*2]" # n 8
d1 silence

d3 $ fast 2 $ s "~ [[ul]*2 ~]" # n 0 # gain 1.2
d3 silence

-- ?
d4 $ fast 2 $ scramble "1 2 3 4" $ s "yeah*4" # n "1 2 3 4"
-- iya
d4 $ fast 2 $ s "voodoo*8" # n "[1 2 3 4]*3" # freq "200 300"
-- heheh
d4 $ fast 2 $ s "sid*8" # n "[1 2 3 4]*3" # freq "100 300 400"
d4 silence

d5 $ juxBy 0.3 rev $ sometimes (fast 2) $ s "psr*8" # n "1 2 3 4 6"
d5 $ juxBy 0.3 rev $ sometimes (fast 2) $ s "industrial*8" # n "2 3 9" # gain 0.9 # freq "100 700"
-- iya
d5 $ juxBy 0.3 rev $ repeatCycles 4 $ sometimes (fast 2) $ s "psr*8" # n (shuffle 5 "1 2 3 4 6")
d5 silence


hush

d4 silence

d1 $ fast 2 $ repeatCycles 4 $ n (shuffle 8 (run 8)) # s "arpy"


shuffle 8 (run 8)

(1 ~>) $ shuffle 8 (run 8)


d1 $ s "bd*4 cp"

-------------------------------
setcps (140/240)

d2 $ s "bd*4"
d2 silence

d1 $ "bd(5,16,1)"
d1 silence

d2 $ s "hh!16"

d3 $ "[~ sn]!2"
d3 silence

d4 $ s "bass1(3,8)" # legato 0.2

hush

---------------------------------
d1 $ repeatCycles 128 $ (0 ~>) $ s "gab!16" # n (irand 13) # up "10,-13,15,-17" # gain 0.7 -- vary (0 ~>)
d1 silence

d2 $ repeatCycles 128 $ s "bottle!16" # n (irand 13) # up "-24,-13,15,-17" # gain 1
d2 silence

d3 $ repeatCycles 128 $ s $ scramble 16 "[bd sn cp hh]!2"
d3 silence

------------------------------- bf

d1 $ s "hitz03" +| n (run 8) # cut 1
d1 silence

d2 $ repeatCycles 8 $ (6 ~>) $ s "arum!16" # n (irand 8) + 24 # cut 1 # gain 1
d2 $ every 2 (degrade) $ repeatCycles 8 $ (6 ~>) $ s "arum!16" # n (irand 8) + 24 # cut 1 # gain 1
d2 silence

hush
d3 $ n "[d3!4 f3!2 c3!2]/2" # s "superreese" # gain 0.9 # sustain 0.4
d3 silence

-------------------------------- bf

d1 $ sometimes (fast 2) $ s "threequal!4" # n "4 5 6 7" # speed "<1 0.25 8>" # room 1 # size 0.5 # orbit 1
d1 silence

d2 $ repeatCycles 4 $ jux rev $ s "threequal!16" # n (irand 16) # speed "1 2 0.75 -0.5" # crush "3 6 9 11" # gain 1
d2 silence

d3 $ degrade $ s "ppsus" +| up (run 8) + 4 # n (run 19) * 2 # waveloss "10 90"
d3 silence

--------------------------------- string trio 18/2/2020

d1 $ s "<tptm!7 tptm!5 tptm!9>*4" # n (irand 3)
d1 silence
hush

d1 $ s "ppsus" +| n " 9 15 21" # freeze 1
hush

d1 $ fast "1 2? 3 4? 5" $ s "tptm!4" # n (irand 32)
d1 $ shuffle 5 $ fast "1 2? 3 4? 5" $ s "tptm!4" # n (irand 32) # freeze 1
d1 $ sometimes (fast "3 4 5") $ s "tptm!4" # n (irand 32) -- # freeze 1
d1 $ sometimes (slow "3 4 0.5") $ s "ppsus!4" # n (irand 2 + 9) --  # octer 1
d1 $ sometimes (fast "3 4") $ s "ppsus!4" # n (irand 2 + 2) --  # octer 1
d1 $ sometimes (slow "3 4") $ s "ppsus!4" # n (irand 7 + 15) # freeze 1 # gain 0.2
d1 silence

play scales in A major, faster
leave out the g#
don't play g#
nico play g natural or any note in key of d
in tempo
strong pulse
driving
faster

violins stop playing c sharps
all using d major
when I say now, suddently to Ab major
now
back to d……… now
suddently out of time, slow long notes
chromatica
microtonal

stop

play, please
I like that
I like the slidey stuff
sounds like we've sort of slid somewhere else
don't build too far
get back to the first lot of sounds
beautiful

we need a sudden gesture
or maybe not

nico, contradict me
disagree strongly

go back to that first texture
I think the piece is ending soon

------------------------ structure experiments

-- d1 $ fast "1 3 5" $ s "superpiano" -- hmm, hard to understand!
d1 $ s "superpiano"
d1 $ n 0 # s "superpiano"
d1 $ n "0 3" # s "superpiano"
d1 $ s "superpiano!2"
d1 $ n "0 3" # s "superpiano!3" -- structure is two notes
d1 $ s "superpiano" # n "0 3" -- structure is one note
d1 $ s "superpiano!3" + n "0 3" -- structure from both patterns
d1 $ s "superpiano!2" # n "0 3 5" -- structure from the left
d1 $ s "superpiano!2" |> n "0 3 5" -- same, structure L values R
d1 $ n "0 3 5" |> s "superpiano" -- same, structure L values R
d1 $ n "0 3 5" <| s "superpiano!5" -- structure R, values L
d1 $ n "0 3 5" +| s "superpiano!5" -- here means the same, not addition
d1 $ n "0 3 5" |< s "superpiano" -- same as |> ? pipe points to structure
d1 $ n "0 3 5" >| s "superpiano!5" -- same as <| ?
d1 $ n "0 3 5" # n "1 2 0 19" # s "superpiano" -- usual struct L values R
d1 $ n "0 3 5" |> n "1 2 0 19" # s "superpiano" -- same
d1 $ n "0 3 5" <| n "19 99 20 19" # s "superpiano" -- struct R ignores values!
d1 $ n "0 3 5" + n "1 2 5 8" # s "superpiano" -- actual addition, combined struct
d1 $ n "0 3 5" |+ n "12 0 0 88" # s "superpiano" -- struct L, addition, 88 ignored
d1 $ n "0 3 5" +| n "0 0 3 9" # s "superpiano" -- struct R, addition
d1 $ n "0 3 5" * n "0 0 3 9" # s "superpiano" -- struct R, mult combined struct
d1 $ n "0 3 5" / n "0 0 3 9" # s "superpiano" -- struct R, division combined struct

d1 silence

---------------------- from tidal-snippets
-- Kind of granular -- slow down while pitch up:

d1 $ fast 20 $ struct (binary 205) $ s "numbers"
# attack 0.02 # hold 0.0 # release 0.02
# begin (slow (2*20) $ range 0.0 0.4 $ saw)
# speed 1.2
# pan rand

d1 silence

--------------------
-- https://chat.toplap.org/channel/tidal?msg=yd7zqq6hFqApxBYRc
d1 $ every 2 rev $ s "{bd@7 bd@7 cp@11 cp bd@13 hh hh hh cp@10}%16"
d1 $ s "{bd cp@4 bd@3 sn@3, arpy}%16"
d1 $ s "[bd cp@4 bd@3 sn@3]*2"
d1 silence

---------------------- domram

d1 $ s "drumtraks" <| n "[6!4, [~ 4]*4, [~ 9]*2] "
d1 $ shuffle 4 $ n (run 8) # s "drumtraks"
d1 $ n (run 8) # s "drumtraks"
d1 $ shuffle 16 $ s "bd sn cp hh" <| n (run 16)
d1 $ repeatCycles 1024 $ (2 ~>) $ shuffle 16 $ s "808bd 808sd 808hh 808" <| n (run 16)
d1 $ repeatCycles 16 $ s "jungle!16" # n (irand 13)
d1 $ repeatCycles 4 $ slow 2 $ s "amencutup!32" # n (irand 32)
d1 $ repeatCycles 4 $ s "peri!16" # n (irand 15) # speed 2 -- iya

d1 silence

----------------------- iya
d1 $ s "drumtraks" <| n "[6!4, [~ 4]*4, [~ 9]*2] "
d2 $ n "0 .. 7" # sound "superzow(5,8)" # octave 3 # gain 0.9
d3 $ n "0" # "superhoover" # octave "[3,4]" # sustain 2 # gain 0.9
d4 $ repeatCycles 4 $ s "peri!16" # n (irand 15) # speed 2 -- y

hush

----------------------

How can I get a polymetric effect across two different patterns? This doesn't work, but something like
`d1 $ s "arpy!4" # n "0 1 2"` where the intention is to have a quarter note pulse with a rotating three note arpeggio that would repeat every three bars `"0 1 2 0  1 2 0 1  2 0 1 2"`

d1 $ fast 3 $ s "arpy!12" <|  n "0 1 2"

d1 $ s "arpy!12" <|  n "[0 1 2]!3" -- tempo is wrong
d1 $ fast (1/3) $ s "arpy" <|  n "[0 1 2]*3"


resetCycles

d1 $ fast (1/3) $ s "arpy" <| n "0 1 2 0 1 2 0 1 2 0 1 2" -- correct, but?!?!? must be a better way

d2 $ s "bd!4"

d1 $ "arpy" # n 2
d1 silence

hush

-- kindohm yay
d1 $ s "arpy*4" # n "{0 1 2}%4"


--------------- chords

jumpIn' 1 1 $ slow 2 $ n "c'maj(5,8) e'min(3,8) d'min(3,8,1) f'maj(5,8)" # s "supermandolin" # sustain 1 # gain 1.1 -- iya
d2 $ s "bd:4!4" # gain 0.8
d2 $ s "[bd:4!4, [~ sn:6]!2]" # gain 0.8
hush
d3 $ n "c3(5,16)" + n "0 12 12 7" # sound "superzow" # gain 0.65 # sustain 0.3

d1 $ every 2 (fast 2) $ s "superpiano" <| n (arp "<converge updown>" "<c'nine ef'dom7'8 a'7sus2*2>")
d2 $ s "superpiano" <| n (arp "<diverge up>" "<c4'nine ef4'dom7'8 a4'7sus2*2>")
d3 $ s "superpiano" <| n (arp "<diverge disconverge>" "<d3'ninesus4 f3'dom7'8 as3'7sus4>")
d4 $ every 2 (slow 2) $ s "superpiano" <| n (arp "<diverge disconverge>" "<e2'm7sharp9 g2'sixby9 af2'3m7sharp5flat9>") -- iya

hush

-------------------

d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (range 0 28 perlin) -- microtonal
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (range 0 28 $ perlinWith saw) -- nope
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (slow 4 $ range 0 28 perlin) -- iya
d1 $ repeatCycles 4 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (slow 4 $ range 0 28 perlin) -- can't see how to vary number of repeat cycles
d1 silence

-- yaxu
d1 $ fast (scramble 4 "7 9 3 5") $ s "bass3:2" |> up (quantise 1 $ range 0 28 perlin)

----------------- sldi

d1 $ repeatCycles 4 $ fast 4 $ loopAt 2 $ shuffle 8 $ chop 8 $ s "sldiwaloops:0" # cut 1 # speed "2 1 0.5" # n "<0 1 2 3>" -- iya
d1 silence

d2 $ s "808bd:2!4" # gain 1.1 -- also load default samples
solo 2
unsolo 2

hush

------------------- iya
setcps (140/60/4)

d1 $ scramble 8 $ s "sixo" <| n (run 8)
d1 $ every 4 (const $ s "sixo!16" # n "{0 4 5}%16") $ scramble 8 $ s "sixo" <| n (run 8)

d2 $ slow 2 $ scramble 16 $ chop 16 $ "sldiwaloops" # cut 1 # n 17 # gain 1 # speed "{0.5 1 0.25}%16"

-- d1 $ s "sixo!8" # n (scramble 8 $ run 8) -- same as above?

hush

------------------- useful

d1 $ s "[mt mt] bd" -- quaver quaver crotchet
d1 $ s "mt*2 bd" -- same
d1 $ s "mt mt . bd" -- same
d1 $ s "mt mt bd" -- triplets
d1 $ s "mt!2 bd" -- triplets

-------------------- pitched sounds in estuary?
-- superpiano default note is A 440
-- pitched samples
-- arpy:0 = C

hush

d1 $ s "superpiano"
d1 $ s "superpiano" # n "cs"
d1 $ s "superpiano" <| n "c cs d ef e f fs g af a bf b c6"
-- d1 $ s "arpy" <| n "c cs d ef e f fs g af a bf b c6" not n!
d1 $ s "arpy" <| up "c cs d ef e f fs g af a bf b c6" -- use up

-------------------- chop like slice
d1 $ slow 2 $ repeatCycles 4 $ shuffle 16 $ chop 16 $ s "sldiwaloops" # n "<0 1>*8"

-------------- different style, 06:23 Sat 21 Mar Ivan Abreu

-- putting it all in one stack more compact, but less flexible?
-- dont' understand why first line out different bit
d1 $ stack [
  n "{0? 1? 2@e 4}%8" # s "{print sid industrial}%4" # gain 0.9,
  n "0!16" # s "metal" # gain (range 0.8 1 $ slow 1.1 saw),
  s "dr2!4" # n "{3 5}%4"
]

-- 2020-03-22
-- on a single sound, can't detect a difference

d1 $ s "{e}%4" |> n "0 1 2 3 5" -- structure of four
d1 $ s "e!4" |> n "0 1 2 3 5" -- also?
d1 $ s "e*4" |> n "0 1 2 3 5" -- also?!
-- test other way
d1 $ s "{e}%4" <| n "0 1 2 3 5" -- same
d1 $ s "e!4" <| n "0 1 2 3 5" -- same
d1 $ s "e*4" <| n "0 1 2 3 5" -- same


d1 $ s "arpy e"
d1 $ s "{arpy e}%4" |> n "2 4 6 8 10" -- four
d1 $ s "[arpy e]!2" |> n "2 4 6 8 10" -- four, but
d1 $ s "[arpy e]*2" |> n "2 4 6 8 10" -- four, but

----------------
asap $ s "sldiwaloops" # n 0

-- no, loopAt repitches
d1 $ loopAt 2 $ s "sldiwaloops" # n 0

-- ok, but very short release, nasty click
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16)
-- this is not right, its like a decay, not a release
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16) # release 0.5
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16) # release 0.5

d1 $ s "sldiwaloops" # n 0 # begin (0/16) # end (1/16)

I'm still struggling with how to neatly use sections from a longer cycle. If I do this, the envelope at the end of the sample is very short indeed, and you get a distinct click at the end:

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16)

If I do this, then it does not do what I would expect, which would be to play up to the 'end' and then add a release tail. Instead of being a 'release', it's more like the 'decay' of an up-and-down a/d envelope.

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16) # release 0.5

In the slicing sampler I use in SC, I have a fast attack but a release tail at the end of the sample of 0.1, which I find works well. How can I do that in Tidal? Do I need to hack SuperDirt?

-----------------

-- ok, this is better than begin and end, but same problem with release
-- (effectively, this is a bit like dice, but not as good)
d1 $ slice 16 "0" $ s "sldiwaloops" # n 0

-- also sustain, still not right
d1 $ s "sldiwaloops" # n 0 # begin (0/16) # sustain (1/16) # release 1

d1 $ s "sldiwaloops" # n 0 # begin (0/16)

-- do synths release correctly?
-- computer says no

d1 $ s "tutorial2a!4"

d2 $ s "909"

-- add extra sustain to allow for a tail?
-- disnae wurk

d1 $ s "bev" # n 0 # begin (0/16) # end (1/16) + 3 # release 0.2

----------------------
-- ideas from building up patterns, meh

d1 $ chunk 4 (|- n 12) $ rarely (ply 2) $ arp "up down pinkyup updown" $ n "c4'maj7 ef4'maj7" # s "supermandolin" # legato 5 # room 0.7 # size 0.9





hush
